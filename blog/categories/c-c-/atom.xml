<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: c/c++ | Olivier Lalonde's blog]]></title>
  <link href="http://syskall.com/blog/categories/c-c-/atom.xml" rel="self"/>
  <link href="http://syskall.com/"/>
  <updated>2014-04-29T03:18:43+08:00</updated>
  <id>http://syskall.com/</id>
  <author>
    <name><![CDATA[Olivier Lalonde]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[How to write your own native Node.js extension]]></title>
    <link href="http://syskall.com/how-to-write-your-own-native-nodejs-extension/index.html"/>
    <updated>2011-05-12T00:00:00+08:00</updated>
    <id>http://syskall.com/how-to-write-your-own-native-nodejs-extension/how-to-write-your-own-native-nodejs-extension</id>
    <content type="html"><![CDATA[<p><strong>UPDATE:</strong> There is now a Node.js addon for loading and calling dynamic libraries using pure JavaScript: <a href="https://github.com/rbranson/node-ffi">node-ffi</a>. Also, <code>node-waf</code> is no longer being used to compile Node.js extensions.</p>

<p><em>TRANSLATIONS</em>: This post was translated to Chinese:
<a href="http://www.oschina.net/translate/how-to-write-your-own-native-nodejs-extension">http://www.oschina.net/translate/how-to-write-your-own-native-nodejs-extension</a></p>

<h2>Introduction</h2>

<p><em>This is a follow up to <a href="http://syskall.com/how-to-roll-out-your-own-javascript-api-with">How to roll out your own Javascript API with V8</a>. You should still be able to follow if you haven't read it.</em></p>

<p>We will now port the <a href="https://github.com/olalonde/node-notify">code we have written for V8</a> to <a href="http://nodejs.org/">Node.js</a> and package it for <a href="http://npmjs.org/">npm</a>.</p>

<p><img src="http://i.imgur.com/n7ZIw.png" alt="node-notify screenshot" /></p>

<p>The full source code of this tutorial is available <a href="https://github.com/olalonde/node-notify">from github</a>:</p>

<pre><code>git clone git://github.com/olalonde/jsnotify.git
</code></pre>

<p>You can also install it through <code>npm</code>:</p>

<pre><code>npm install notify
</code></pre>

<p>The code was tested on Ubuntu 10.10 64-bit and Node.js v0.5.0-pre.</p>

<h2>Getting started</h2>

<p>First let’s create a node-notify folder and with the following directory structure.</p>

<pre><code>.
|-- build/                   # This is where our extension is built. 
|-- demo/
|   `-- demo.js              # This is a demo Node.js script to test our extension.
|-- src/
|   `-- node_gtknotify.cpp   # This is the where we do the mapping from C++ to Javascript.
`-- wscript                  # This is our build configuration used by node-waf
</code></pre>

<p><em>This fine looking tree was generated with the <code>tree</code> utility.</em></p>

<p>Now let's create our test script <code>demo.js</code> and decide upfront what our extension's API should look like:</p>

<p>```javascript
// This loads our extension on the notify variable.
// It will only load a constructor function, notify.notification().
var notify = require("../build/default/gtknotify.node"); // path to our extension</p>

<p>var notification = new notify.notification();
notification.title = "Notification title";
notification.icon = "emblem-default"; // see /usr/share/icons/gnome/16x16
notification.send("Notification message");  <br/>
```</p>

<h2>Writing our Node.js extension</h2>

<h3>The Init method</h3>

<p>In order to create a Node.js extension, we need to write a C++ class that extends <a href="https://github.com/joyent/node/blob/master/src/node_object_wrap.h">node::ObjectWrap</a>. ObjectWrap implements some utility methods that lets us easily interface with Javascript.</p>

<p>Let's write the skeletton for our class:</p>

<p>```cpp</p>

<h1>include &lt;v8.h> // v8 is the Javascript engine used by Node</h1>

<h1>include &lt;node.h></h1>

<p>// We will need the following libraries for our GTK+ notification</p>

<h1>include <string></h1>

<h1>include &lt;gtkmm.h></h1>

<h1>include &lt;libnotifymm.h></h1>

<p>using namespace v8;</p>

<p>class Gtknotify : node::ObjectWrap {
  private:
  public:</p>

<pre><code>Gtknotify() {}
~Gtknotify() {}
static void Init(Handle&lt;Object&gt; target) {
  // This is what Node will call when we load the extension through require(), see boilerplate code below.
}
</code></pre>

<p>};</p>

<p>/<em>
 * WARNING: Boilerplate code ahead.
 *
 * See https://www.cloudkick.com/blog/2010/aug/23/writing-nodejs-native-extensions/ &amp; http://www.freebsd.org/cgi/man.cgi?query=dlsym
 </em><br/>
 * Thats it for actual interfacing with v8, finally we need to let Node.js know how to dynamically load our code.
 * Because a Node.js extension can be loaded at runtime from a shared object, we need a symbol that the dlsym function can find,
 * so we do the following:<br/>
 */</p>

<p>v8::Persistent<FunctionTemplate> Gtknotify::persistent_function_template;
extern "C" { // Cause of name mangling in C++, we use extern C here
  static void init(Handle<Object> target) {</p>

<pre><code>Gtknotify::Init(target);
</code></pre>

<p>  }
  // @see http://github.com/ry/node/blob/v0.2.0/src/node.h#L101
  NODE_MODULE(gtknotify, init);
}
```</p>

<p>Now, we'll have to we have to write the following code in our Init() method:</p>

<ol>
<li>Declare our constructor function and bind it to our target variable. <code>var n = require("notification");</code> will bind notification() to n: <code>n.notification()</code>.</li>
</ol>


<p>```cpp      <br/>
// Wrap our C++ New() method so that it's accessible from Javascript
// This will be called by the new operator in Javascript, for example: new notification();
v8::Local<FunctionTemplate> local_function_template = v8::FunctionTemplate::New(New);</p>

<p>// Make it persistent and assign it to persistent_function_template which is a static attribute of our class.
Gtknotify::persistent_function_template = v8::Persistent<FunctionTemplate>::New(local_function_template);</p>

<p>// Each JavaScript object keeps a reference to the C++ object for which it is a wrapper with an internal field.
Gtknotify::persistent_function_template->InstanceTemplate()->SetInternalFieldCount(1); // 1 since a constructor function only references 1 object
// Set a "class" name for objects created with our constructor
Gtknotify::persistent_function_template->SetClassName(v8::String::NewSymbol("Notification"));</p>

<p>// Set the "notification" property of our target variable and assign it to our constructor function
target->Set(String::NewSymbol("notification"), Gtknotify::persistent_function_template->GetFunction());
```</p>

<ol>
<li>Declare our attributes: <code>n.title</code> and <code>n.icon</code>.</li>
</ol>


<p><code>cpp        
// Set property accessors
// SetAccessor arguments: Javascript property name, C++ method that will act as the getter, C++ method that will act as the setter
Gtknotify::persistent_function_template-&gt;InstanceTemplate()-&gt;SetAccessor(String::New("title"), GetTitle, SetTitle);
Gtknotify::persistent_function_template-&gt;InstanceTemplate()-&gt;SetAccessor(String::New("icon"), GetIcon, SetIcon);
// For instance, n.title = "foo" will now call SetTitle("foo"), n.title will now call GetTitle()
</code></p>

<ol>
<li>Declare our prototype method: <code>n.send()</code></li>
</ol>


<p><code>cpp        
// This is a Node macro to help bind C++ methods to Javascript methods (see https://github.com/joyent/node/blob/v0.2.0/src/node.h#L34)
// Arguments: our constructor function, Javascript method name, C++ method name
NODE_SET_PROTOTYPE_METHOD(Gtknotify::persistent_function_template, "send", Send);
</code></p>

<p>Our Init() method should now look like this:</p>

<p>```cpp      <br/>
// Our constructor
static v8::Persistent<FunctionTemplate> persistent_function_template;</p>

<p>static void Init(Handle<Object> target) {
  v8::HandleScope scope; // used by v8 for garbage collection</p>

<p>  // Our constructor
  v8::Local<FunctionTemplate> local_function_template = v8::FunctionTemplate::New(New);
  Gtknotify::persistent_function_template = v8::Persistent<FunctionTemplate>::New(local_function_template);
  Gtknotify::persistent_function_template->InstanceTemplate()->SetInternalFieldCount(1); // 1 since this is a constructor function
  Gtknotify::persistent_function_template->SetClassName(v8::String::NewSymbol("Notification"));</p>

<p>  // Our getters and setters
  Gtknotify::persistent_function_template->InstanceTemplate()->SetAccessor(String::New("title"), GetTitle, SetTitle);
  Gtknotify::persistent_function_template->InstanceTemplate()->SetAccessor(String::New("icon"), GetIcon, SetIcon);</p>

<p>  // Our methods
  NODE_SET_PROTOTYPE_METHOD(Gtknotify::persistent_function_template, "send", Send);</p>

<p>  // Binding our constructor function to the target variable
  target->Set(String::NewSymbol("notification"), Gtknotify::persistent_function_template->GetFunction());
}
```</p>

<p>All that is left to do is to write the C++ methods that we used in our Init method: <code>New</code>, <code>GetTitle</code>, <code>SetTitle</code>, <code>GetIcon</code>, <code>SetIcon</code>, <code>Send</code></p>

<h3>Our constructor method: New()</h3>

<p>The New() method creates an instance of our class (a Gtknotify object), sets some default values to our properties and returns a Javascript handle to this object. This is the expected behavior when calling a constructor function with the new operator in Javascript.</p>

<p>```cpp<br/>
std::string title;
std::string icon;</p>

<p>// new notification()
static Handle<Value> New(const Arguments&amp; args) {
  HandleScope scope;
  Gtknotify* gtknotify_instance = new Gtknotify();
  // Set some default values
  gtknotify_instance->title = "Node.js";
  gtknotify_instance->icon = "terminal";</p>

<p>  // Wrap our C++ object as a Javascript object
  gtknotify_instance->Wrap(args.This());</p>

<p>  return args.This();
}
```</p>

<h3>Our getters and setters: GetTitle(), SetTitle(), GetIcon(), SetIcon()</h3>

<p>The following is pretty much boilerplate code. It boils down to back and forth conversion between C++ values to Javascript (V8) values.</p>

<p><code>cpp
// this.title
static v8::Handle&lt;Value&gt; GetTitle(v8::Local&lt;v8::String&gt; property, const v8::AccessorInfo&amp; info) {
  // Extract the C++ request object from the JavaScript wrapper.
  Gtknotify* gtknotify_instance = node::ObjectWrap::Unwrap&lt;Gtknotify&gt;(info.Holder());
  return v8::String::New(gtknotify_instance-&gt;title.c_str());
}
// this.title=
static void SetTitle(Local&lt;String&gt; property, Local&lt;Value&gt; value, const AccessorInfo&amp; info) {
  Gtknotify* gtknotify_instance = node::ObjectWrap::Unwrap&lt;Gtknotify&gt;(info.Holder());
  v8::String::Utf8Value v8str(value);
  gtknotify_instance-&gt;title = *v8str;
}
// this.icon
static v8::Handle&lt;Value&gt; GetIcon(v8::Local&lt;v8::String&gt; property, const v8::AccessorInfo&amp; info) {
  // Extract the C++ request object from the JavaScript wrapper.
  Gtknotify* gtknotify_instance = node::ObjectWrap::Unwrap&lt;Gtknotify&gt;(info.Holder());
  return v8::String::New(gtknotify_instance-&gt;icon.c_str());
}
// this.icon=
static void SetIcon(Local&lt;String&gt; property, Local&lt;Value&gt; value, const AccessorInfo&amp; info) {
  Gtknotify* gtknotify_instance = node::ObjectWrap::Unwrap&lt;Gtknotify&gt;(info.Holder());
  v8::String::Utf8Value v8str(value);
  gtknotify_instance-&gt;icon = *v8str;
}
</code></p>

<h3>Our prototype method: Send()</h3>

<p>First we have to extract the C++ object <code>this</code> references. We then build our notification using the object's properties (title, icon) and finally display it.</p>

<p>```cpp
// this.send()
static v8::Handle<Value> Send(const Arguments&amp; args) {
  v8::HandleScope scope;
  // Extract C++ object reference from "this"
  Gtknotify* gtknotify_instance = node::ObjectWrap::Unwrap<Gtknotify>(args.This());</p>

<p>  // Convert first argument to V8 String
  v8::String::Utf8Value v8str(args[0]);</p>

<p>  // For more info on the Notify library: http://library.gnome.org/devel/libnotify/0.7/NotifyNotification.html
  Notify::init("Basic");
  // Arguments: title, content, icon
  Notify::Notification n(gtknotify_instance->title.c_str(), <em>v8str, gtknotify_instance->icon.c_str()); // </em>v8str points to the C string it wraps
  // Display the notification
  n.show();
  // Return value
  return v8::Boolean::New(true);
}
```</p>

<h2>Compiling our extension</h2>

<p><code>node-waf</code> is the build tool used to compile Node extensions which is basically a wrapper for <a href="http://code.google.com/p/waf/">waf</a>. The build process can be configured with a file called <code>wscript</code> in our top directory:</p>

<p>```python  <br/>
def set_options(opt):
  opt.tool_options("compiler_cxx")</p>

<p>def configure(conf):
  conf.check_tool("compiler_cxx")
  conf.check_tool("node_addon")
  # This will tell the compiler to link our extension with the gtkmm and libnotifymm libraries.
  conf.check_cfg(package='gtkmm-2.4', args='--cflags --libs', uselib_store='LIBGTKMM')
  conf.check_cfg(package='libnotifymm-1.0', args='--cflags --libs', uselib_store='LIBNOTIFYMM')</p>

<p>def build(bld):
  obj = bld.new_task_gen("cxx", "shlib", "node_addon")
  obj.cxxflags = ["-g", "-D_FILE_OFFSET_BITS=64", "-D_LARGEFILE_SOURCE", "-Wall"]
  # This is the name of our extension.
  obj.target = "gtknotify"
  obj.source = "src/node_gtknotify.cpp"
  obj.uselib = ['LIBGTKMM', 'LIBNOTIFYMM']
```</p>

<p>We're now ready to build! In the top directory, run the following command:</p>

<pre><code>node-waf configure &amp;&amp; node-waf build
</code></pre>

<p>If everything goes right, we should now have our compiled extension in <code>./build/default/gtknotify.node</code>. Let's try it!</p>

<p>```bash
$ node</p>

<blockquote><p>var notif = require('./build/default/gtknotify.node');
n = new notif.notification();
{ icon: 'terminal', title: 'Node.js' }
n.send("Hello World!");
true
```</p></blockquote>

<p>The previous code should display a notification in the top right corner of your screen!</p>

<h2>Packaging for npm</h2>

<p>That's pretty cool, but how about sharing your hard work with the Node community? That's primarily what the Node Package Manager is used for: making it easy to import extensions/modules and distribute them.</p>

<p>Packaging an extension for npm is very straightforward. All you have to do is create a <code>package.json</code> file in your top directory which contains some info about your extension:</p>

<p>```javascript  <br/>
{
  // Name of your extension (do not include node or js in the name, this is implicit).
  // This is the name that will be used to import the extension through require().</p>

<p>  "name" : "notify",</p>

<p>  // Version should be http://semver.org/ compliant</p>

<p>  "version" : "v0.1.0"</p>

<p>  // These scripts will be run when calling npm install and npm uninstall.</p>

<p>  , "scripts" : {</p>

<pre><code>  "preinstall" : "node-waf configure &amp;&amp; node-waf build"
  , "preuninstall" : "rm -rf build/*"
}
</code></pre>

<p>  // This is the relative path to our built extension.</p>

<p>  , "main" : "build/default/gtknotify.node"</p>

<p>  // The following fields are optional:</p>

<p>  , "description" : "Description of the extension...."
  , "homepage" : "https://github.com/olalonde/node-notify"
  , "author" : {</p>

<pre><code>  "name" : "Olivier Lalonde"
  , "email" : "olalonde@gmail.com"
  , "url" : "http://www.syskall.com/"
} 
</code></pre>

<p>  , "repository" : {</p>

<pre><code>  "type" : "git"
  , "url" : "https://github.com/olalonde/node-notify.git"
}
</code></pre>

<p>}
```</p>

<p><em>For more details on the package.json format, documentation is available through <code>npm help json</code>. Note that most fields are optional.</em></p>

<p>You can now install your new npm package by running <code>npm install</code> in your top directory. If everything goes right, you should be able to load your extension with a simple <code>var notify = require('your-package-name');</code>. Another useful command is <code>npm link</code> which creates a symlink to your development directory so that any change to your code is reflected instantly - no need to install/uninstall perpetually.</p>

<p>Assuming you wrote a cool extension, you might want to publish it online in the central npm repository. In order to do that, you first need to create an account:</p>

<pre><code>$ npm adduser
</code></pre>

<p>Next, go back to the root of your package code and run:</p>

<pre><code>$ npm publish
</code></pre>

<p>That's it, your package is now available for anyone to install through the <code>npm install your-package-name</code> command.</p>

<h2>Conclusion</h2>

<p>Writing a native Node extension can be cumbersome and verbose at times but it is well worth the hard earned bragging rights!</p>

<p>Thanks for reading. Let me know in the comments if you run into any problem, I’ll be glad to help.</p>

<p><em>If you liked this, maybe you'd also like what I <a href="http://twitter.com/o_lalonde">tweet on Twitter</a>! Might even want to <a href="mailto:olalonde@gmail.com">hire me</a>?</em></p>

<h2>References</h2>

<ul>
<li><a href="http://syskall.com/how-to-roll-out-your-own-javascript-api-with">How to roll out your own Javascript API with V8</a></li>
<li><a href="https://www.cloudkick.com/blog/2010/aug/23/writing-nodejs-native-extensions/">Writing Node.js Native Extensions</a></li>
<li><a href="http://code.google.com/apis/v8/embed.html">V8 JavaScript Engine Embedder's Guide</a></li>
<li><a href="http://howtonode.org/introduction-to-npm">Introduction to npm</a></li>
<li><a href="http://nodejs.org/">Node.js</a></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Minimalist shell in C (for educational purposes only!)]]></title>
    <link href="http://syskall.com/minimalist-shell-in-c-for-educational-purpose/index.html"/>
    <updated>2011-03-10T00:00:00+08:00</updated>
    <id>http://syskall.com/minimalist-shell-in-c-for-educational-purpose/minimalist-shell-in-c-for-educational-purpose</id>
    <content type="html"><![CDATA[<h2>Introduction</h2>

<p>I was kind of bored tonight so I decided to write a very minimalist
shell in C. Here's how it looks:</p>

<p>```c
/<em>
 * DISCLAIMER: THIS CODE IS FOR EDUCATIONAL PURPOSES ONLY. USE AT YOUR OWN RISKS.
 *
 * This code shows the basic workings of a shell.
 *
 * Append "/path/to/dashell" to /etc/shells, to make it a valid shell:
 * sudo echo "/path/to/dashell" >> /etc/shells
 *
 * Change your "username"'s shell. "username" should have execute permission for the shell:
 * chsh --shell /path/to/dashell username
 *
 </em>/</p>

<h1>include &lt;unistd.h></h1>

<h1>include &lt;string.h></h1>

<h1>include &lt;stddef.h></h1>

<h1>include &lt;stdlib.h></h1>

<h1>include &lt;stdio.h></h1>

<h1>include &lt;ctype.h></h1>

<h1>include &lt;sys/signal.h></h1>

<h1>define STDIN 0</h1>

<h1>define STDOUT 1</h1>

<h1>define STDERR 2</h1>

<h1>define BUFFER_SIZE 1024</h1>

<p>void parse_arguments(char buffer[], int <em>args_count, char </em>args[]) {
  char <em>delimiters = " \r\n";
  char </em>token;
  *args_count = 0;
  // "abc def ghi" => {"abc", "def", "ghi"}
  while(token = strsep(&amp;buffer, delimiters)) {</p>

<pre><code>args[*args_count] = token;
(*args_count)++;
</code></pre>

<p>  }
}</p>

<p>int main(int argc, const char* argv[]) {
  // The weird characters are used to format the text's appearance.
  // See http://en.wikipedia.org/wiki/ANSI_escape_code
  char prompt[] = "\033[1mdashell\033[2m>\033[0m ";
  char exec_error[] = "Cannot execute program %s.\n";
  char buffer[BUFFER_SIZE + 1];</p>

<p>  int args_count;
  char *args[BUFFER_SIZE];</p>

<p>  int n;
  while(1) {</p>

<pre><code>write(STDOUT, prompt, strlen(prompt) + 1);
n = read(STDIN, buffer, BUFFER_SIZE); // Read from STDIN (keyboard input)
buffer[n] = '\0'; // Null character to indicate string end

// "abc def ghi" =&gt; {"abc", "def", "ghi"}
parse_arguments(buffer, &amp;args_count, args);

// No arguments
if(args_count == 0 || strcmp(args[0], "") == 0) continue;

// Argument = exit
if(strcmp(args[0], "exit") == 0) exit(0);

pid_t child_pid = fork(); // Duplicate process
if(child_pid == 0) {
  // Child
  if(execvp(args[0], args) &lt; 0) { // Replace executable code by command passed
    fprintf(stderr, exec_error, args[0]);
  }
}
else {
  // Parent
  // Wait for child to finish
  wait();
}
</code></pre>

<p>  }
}
```</p>

<p>The full source code is freely <a href="https://github.com/olalonde/dashell">available at Github</a>:</p>

<pre><code>git clone git://github.com/olalonde/dashell.git
</code></pre>

<p>Note that I never code in C so it might not be perfect... I'm looking at you <code>parse_arguments()</code> ;)</p>

<h2>Install &amp; have fun</h2>

<p>The optional steps will let you use the shell as a login shell for a given user.</p>

<ol>
<li><p><code>make</code></p></li>
<li><p>(optional) Append "/path/to/dashell" to /etc/shells, to make it a
valid shell:</p></li>
</ol>


<p><code>bash
sudo echo "/path/to/dashell" &gt;&gt; /etc/shells
</code></p>

<ol>
<li>(optional) Change "username"'s shell. "username" should have
execute permission for the shell:</li>
</ol>


<p><code>bash
chsh --shell /path/to/dashell username
</code></p>

<p>Now, you can launch the shell and start having fun with it and be
reminded how great bash really is!</p>

<p><code>bash
./dashell
dashell&gt; ls -al
dashell&gt; ./launchme 1 2 3
....
dashell&gt; exit
</code></p>

<p>Feel free to ask questions!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[How to roll out your own Javascript API with V8]]></title>
    <link href="http://syskall.com/how-to-roll-out-your-own-javascript-api-with/index.html"/>
    <updated>2011-02-26T00:00:00+08:00</updated>
    <id>http://syskall.com/how-to-roll-out-your-own-javascript-api-with/how-to-roll-out-your-own-javascript-api-with</id>
    <content type="html"><![CDATA[<p><em>Update: I wrote a new tutorial on porting our V8 code as a Node.js extension: <a href="http://syskall.com/how-to-write-your-own-native-nodejs-extension">How to write your own native Node.js extension</a>.</em></p>


<h2>Introduction</h2>

<p>This tutorial will teach you how to:</p>

<ol>
<li>Compile the V8 Javascript engine</li>
<li>Bind a Javascript function to your own C++ function</li>
</ol>


<p>For the sake of demonstration and to impress your co-workers, we will bind a Javascript function "alert()“ that will display desktop notifications through the GTK library. Here’s what the end result looks like:</p>

<p><img src="http://i.imgur.com/nUsWG.png" alt="jsnotify screenshot" /></p>

<p>You can get the full source code of this tutorial <a href="https://github.com/olalonde/jsnotify">from github</a>:</p>

<pre><code>git clone git://github.com/olalonde/jsnotify.git
</code></pre>

<p>This tutorial was tested on Ubuntu 10.04 and 10.10 64-bit but should work fine on any Linux distribution. The notification part requires the GTK+ library.</p>

<h2>Compiling Google’s V8 Javascript engine</h2>

<p>First, let’s make sure we have all the <a href="http://code.google.com/apis/v8/build.html">required tools and dependencies</a> to compile.</p>

<pre><code>sudo apt-get install build-essential scons subversion 
</code></pre>

<ul>
<li>The build-essential package is a meta package that installs all the necessary tools and libraries to compile C++ programs.</li>
<li>SCons is a build tool which attempts to replace the classic “make” and is used by the V8 project.</li>
<li>Subversion is needed to checkout the source code of V8.</li>
</ul>


<p>Now, let’s grab V8’s source from the <a href="http://code.google.com/p/v8/wiki/Source?tm=4">official repository</a>:</p>

<pre><code>svn checkout http://v8.googlecode.com/svn/trunk/ v8 
</code></pre>

<p>We can now move into the V8 directory and try to compile!</p>

<pre><code>cd v8;
scons arch=x64; 
</code></pre>

<p>The “arch=x64” option specifies that we want to build a 64-bit version of V8 (the default value would be 32-bit otherwise).</p>

<p>If V8 compiled fine, you should now have a libv8.a file in your v8/ directory. As you probably guessed, libv8.a is the library that our C++ program will use to execute Javascript code.</p>

<p>So, if everything compiled fine, just skip to the next section. Otherwise, keep on reading.</p>

<p>When you get errors as a result of compiling third party code, it is usually due to the fact that the compiler can’t find required libraries (/usr/lib) and/or their associated header files (/usr/lib/include). The latter are usually available through packages conventionally named <em>libname</em>-dev . In order to find out which package installs a given file, there is a neat utility called <code>apt-file</code>.</p>

<pre><code>sudo apt-get install apt-file;
apt-file search missing-header-file.h; 
</code></pre>

<p>The <code>apt-file search</code> command lists the package(s) that install a given file (<em>missing-header-file.h</em> in this case). If there are more than one package listed, we have to take a semi-educated guess on which package we should install based on its name (let me know in the comments if you know of a better trick!). We then simply install the package with the usual <code>apt-get install package-name</code> command.</p>

<p>Hint: If you are on Ubuntu 10.04, you might need to install the following packages:</p>

<pre><code>sudo apt-get install libc6-dev-i368 lib32stdc++6
</code></pre>

<p>Now that we’ve installed all the missing files, the compilation should work. Let's move on to the next section.</p>

<p>If you are still stuck with compiling V8, <a href="http://www.travisswicegood.com/2009/07/11/compiling-node-js-olibc6-dev-i368n-ubuntu-9-04/">this tutorial</a> might help.</p>

<h2>Building our own Javascript API</h2>

<p>Now that we have successfully compiled the V8 library, we will build our own C++ project that will be “Javascript scriptable”. This means that our program will be able to run Javascript code which in turn will be able to call our custom C++ functions.</p>

<p><em>Note:</em> You can also get the full source code of this tutorial from my <a href="(https://github.com/olalonde/jsnotify">jsnotify github repository</a>): <code>git clone git://github.com/olalonde/jsnotify.git</code></p>

<p>First let’s create our file structure.</p>

<pre><code>jsnotify/
  |-- deps/  # third party code
  |   `-- v8  # move your v8 folder here
  `-- src/ # our code goes here
      `-- jsnotify.cpp
</code></pre>

<p>Now let’s copy the sample code available at <code>deps/v8/samples/shell.cc</code> and paste it into jsnotify.cpp. The sample code given by V8 let’s you execute a Javascript file or start an interactive Javascript shell. It also binds some useful Javascript functions such as print() which will output text to the terminal.</p>

<p>Let’s try to compile this!</p>

<pre><code>g++ src/jsnotify.cpp; 
</code></pre>

<p>Of course, this gives us a bunch of errors since we haven’t specified where the V8 header and library files are. Let’s try again!</p>

<pre><code>g++ src/jsnotify.cpp -Ideps/v8/include -Ldeps/v8/ -lv8
</code></pre>

<p>Oops, still some errors. Looks like we also have to link the pthread library.</p>

<pre><code>g++ src/jsnotify.cpp -Ideps/v8/include -Ldeps/v8/ -lv8 -lpthread
</code></pre>

<p>This finally compiles! Now that we have our mini Javascript shell, let’s play a bit with it.</p>

<p>```bash
$ ./a.out
V8 version 3.1.5</p>

<blockquote><p>var foo = “Hello World”;
print(foo);
Hello World
```</p></blockquote>

<p>Now, all we have to do is to create our custom alert() function in C++.</p>

<p>```cpp
// INSERT THIS BEFORE int RunMain(int argc, char* argv[]) {
// We need those two libraries for the GTK+ notification</p>

<h1>include &lt;gtkmm.h></h1>

<h1>include &lt;libnotifymm.h></h1>

<p>v8::Handle&lt;v8::Value> Alert(const v8::Arguments&amp; args);</p>

<p>// INSERT THIS AT END OF FILE <br/>
// The callback that is invoked by v8 whenever the JavaScript 'alert'
// function is called.  Displays a GTK+ notification.
v8::Handle&lt;v8::Value> Alert(const v8::Arguments&amp; args) {
  v8::String::Utf8Value str(args[0]); // Convert first argument to V8 String
  const char* cstr = ToCString(str); // Convert V8 String to C string</p>

<p>  Notify::init("Basic");
  // Arguments: title, content, icon
  Notify::Notification n("Alert", cstr, "terminal");
  // Display notification
  n.show();</p>

<p>  return v8::Undefined();
}
```</p>

<p>Now that we have our Alert C++ function, we need to tell V8 to bind it to the Javascript alert() function. This is done by adding the following code in the RunMain function:</p>

<p><code>cpp
// INSERT AFTER v8::Handle&lt;v8::ObjectTemplate&gt; global = v8::ObjectTemplate::New();
// Bind the global 'alert' function to the C++ Alert callback.
global-&gt;Set(v8::String::New("alert"), v8::FunctionTemplate::New(Alert));
</code></p>

<p>Now, in order to compile, the compiler needs to know where to find the two header files we introduced. This is done using the pkg-config utility:</p>

<pre><code>g++ src/jsnotify.cpp -Ideps/v8/include -Ldeps/v8/ -lv8 -lpthread `pkg-config --cflags --libs gtkmm-2.4 libnotifymm-1.0`
</code></pre>

<p>We can now try our new alert function.</p>

<p>```bash
$./a.out
V8 version 3.1.5</p>

<blockquote><p>alert(“wow, it works!”);<br/>
```</p></blockquote>

<p>You should see a nice notification in the top right of your screen! Note that you can also put you Javascript code in a file and pass the file name as an argument <code>./a.out filename.js</code>.</p>

<h2>Conclusion</h2>

<p>It's quite easy to make a C++ program "Javascriptable" with V8 and the proper setup. If you'd like to practice your newfound skills, I suggest you try to add a title argument to the alert function. You might also want to follow me on Posterous if you'd like to be informed when I post the follow up to this tutorial which will explain how to extend <a href="http://nodejs.org/">Node.js</a> with our alert function.</p>

<p>That’s all for today, thanks for reading! Let me know in the comments if you run into any problem, I’ll be glad to help.</p>

<p><em>If you liked this, maybe you'd also like what I <a href="http://twitter.com/o_lalonde">tweet on Twitter</a>!</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[MultiVac, the line tracking robot]]></title>
    <link href="http://syskall.com/multivac-the-line-tracking-robot/index.html"/>
    <updated>2010-11-09T00:00:00+08:00</updated>
    <id>http://syskall.com/multivac-the-line-tracking-robot/multivac-the-line-tracking-robot</id>
    <content type="html"><![CDATA[<p>Here's a line tracking robot I built with friends at university. I thought I would post it here before it sinks into oblivion. It was built using a 16bit&nbsp;micro-controller (<a href="http://www.atmel.com/dyn/products/product_card.asp?PN=ATmega16">ATmega16</a>), a PCB, a small motor and some sensors. The programming was done in C/C++. Source code and hardware (if you can pick it up - Montreal) available <a href="http://twitter.com/olivierll">upon request</a>.</p>


<p>
<object height="385" width="480">
<param name="movie" value="http://www.youtube.com/v/bndYfanDBS8?fs=1&amp;hl=en_US" />
<param name="allowFullScreen" value="true" />
<param name="allowscriptaccess" value="always" /><embed src="http://www.youtube.com/v/bndYfanDBS8?fs=1&amp;hl=en_US" type="application/x-shockwave-flash" height="385" width="480"></embed>
</object>
</p>


<p>Any ideas of how I could turn it into something useful? I also got a proximity sensor if that can be of any use.</p>

]]></content>
  </entry>
  
</feed>
